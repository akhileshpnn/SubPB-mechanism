# -*- coding: utf-8 -*-
"""
Created on Mon Aug  3 13:57:58 2020

@author: nandan
"""

import numpy as np
from scipy.signal import gaussian


'''
This file contains several claases that generates a spatial gradient. 
see the main article S1A Fig and  'Model implementation' sub section in 'Materials and methods'
for more details. The details are for generating single gradient. Gradient reversal and Simultaneous
gradients are generated by doing numpy array calculations.

'''

class single_gradient:
    
    t_beg1 = 0;
    
    beg_range=2; end_range= 2
    
    def add_stimulus(self, t):
        
        t_end1 = self.tF # gardient terminating time
        
        extend1=((self.end_range-self.beg_range)*(t-self.t_beg1)**2/(t_end1-self.t_beg1)**2)+self.beg_range # determines the spatial extend of stimulus
        
        if self.t_beg1<=t<=t_end1:
            grad = self.stimu_strength*gaussian(self.N,extend1,sym=False)
        else:
            grad = np.zeros(self.N)
        return grad    

class single_gradient_transient:
    
    t_beg1 = 10;
    
    beg_range=2; end_range= 2
    
    def add_stimulus(self, t):
        t_end1=70
        extend1=((self.end_range-self.beg_range)*(t-self.t_beg1)**2/(t_end1-self.t_beg1)**2)+self.beg_range
        if self.t_beg1<=t<=t_end1:
            grad = self.stimu_strength*gaussian(self.N,extend1,sym=False)
        else:
            grad = np.zeros(self.N)
        return grad  


class gradient_reversal:
    
    t_beg1 = 0   # time at which first gradient is initiated
    t_end1 = 300 # time at which first gradient is terminated
    t_beg2 = 300 # time at which reversed gradient is established
    
    beg_range=2; end_range= 2 # determines the spatial extent of the gradient.
    
    def add_stimulus(self, t):
        
        t_end2=self.tF # time at which reversed gradient is terminated 
        extend1=((self.end_range-self.beg_range)*(t-self.t_beg1)**2/(self.t_end1-self.t_beg1)**2)+self.beg_range
        extend2=((self.end_range-self.beg_range)*(t-self.t_beg2)**2/(t_end2-self.t_beg2)**2)+self.beg_range

        if self.t_beg1<=t<=self.t_end1:  
            grad = self.threshold_stimu*gaussian(self.N,extend1,sym=False)     
        elif self.t_beg2<=t<=t_end2:  
            grad = self.stimu_strength*gaussian(self.N,extend2,sym=False)    
            grad=np.roll(grad,10) # gradient reversal is done by traslating the the current gradient by 10 bins.
            # This translation ensures gradient reversal by 180 degrees because we have used 20 spatial bins in total.
        else:
            grad = np.zeros(self.N)
        return grad

    
class simultaneous_gradients:
    t_beg1=0;  
    
    beg_range1=2; end_range1=2 
    beg_range2=2; end_range2=2 
 
    
    def add_stimulus(self, t):
        t_end1=self.tF
        
        extend1=((self.end_range1-self.beg_range1)*(t-self.t_beg1)**2/(t_end1-self.t_beg1)**2)+self.beg_range1
        extend2=((self.end_range2-self.beg_range2)*(t-self.t_beg1)**2/(t_end1-self.t_beg1)**2)+self.beg_range2

        if self.t_beg1<=t<=t_end1:
            
            grad1 = self.threshold_stimu*gaussian(self.N,extend1,sym=False) # gradient at one side
            grad2 = self.stimu_strength*gaussian(self.N,extend2,sym=False) # for gradient at the opposite side
            grad2=np.roll(grad2,10)# gradient at the opposite side side
            grad = grad1+grad2
            grad=np.round(grad,3) # gradient with non-zero stimulus strength at dimetrically opposite sides.

        else:
            grad = np.zeros(self.N)

        return grad

